"""                                     Модуль 8. Серіалізація та копіювання об'єктів в Python

                        Вступ
                        
У цьому модулі ми розберемося, як передавати, шифрувати та дешифрувати потоки даних.

Розглянемо такі теми:

- Серіалізація об'єктів Python
- Серіалізація об'єктів за допомогою pickle
- Серіалізація за допомогою JSON
- Робота з таблицями CSV
- Управління порядком серіалізації
- Створення копій об'єктів
- Створення поверхневих копій об'єктів
- Управління порядком копіювання об'єктів Python

В результаті проходження модуля, ти дізнаєшся, що таке серіалізація та як дані в програмі передаються між різними 
модулями.


                        Серіалізація об'єктів в Python
                        
Серіалізація об'єктів в Python — це процес перетворення структури даних або об'єкта в потік байтів для зберігання 
або передачі. Цей потік байтів може бути збережений у файлі, переданий через мережу або навіть використаний для 
зберігання в базі даних. Ціль серіалізації — зберегти стан об'єкта так, щоб його можна було відновити в майбутньому. 
Процес відновлення стану об'єкта з серіалізованої форми називається десеріалізацією.

Завжди, коли потрібно зберегти інформацію для подальшого використання в зрозумілій комп'ютеру формі, робимо 
серіалізацію. Найочевидніший приклад — це збереження даних у текстовий файл. Ти можеш зберегти, наприклад, перелік 
витрат у текстовий файл:"""

expenses = {"hotel": 150, "breakfast": 30, "taxi": 15, "lunch": 20}

file_name = "expenses.txt"
with open(file_name, "w") as fh:
    for key, value in expenses.items():
        fh.write(f"{key}|{value}\n")

""" Цей файл буде повністю читабельним:

hotel|150
breakfast|30
taxi|15
lunch|20

Якщо потім знадобиться завантажити цей перелік назад у Python, завжди є змога це зробити:"""

file_name = "expenses.txt"
expenses = {}

with open(file_name, "r") as fh:
    raw_expenses = fh.readlines()
    for line in raw_expenses:
        key, value = line.split("|")
        expenses[key] = int(value)

print(expenses)

""" Виведення:{'hotel': 150, 'breakfast': 30, 'taxi': 15, 'lunch': 20}

У цьому примітивному прикладі ми серіалізували та десеріалізували словник expenses. Такий підхід цілком виправданий, 
особливо, якщо варто зберегти інформативний вигляд інформації.

Однак, далеко не завжди такий підхід виправданий. Зауваж, що у цьому прикладі довелося винайти свій протокол 
серіалізації. А саме:
- символ нового рядка вказує на початок нової пари ключ-значення;
- символ | розділяє ключ і значення
- значення потрібно перетворити з рядкового представлення на числову форму.

Для роботи з даними, серіалізованими за цим протоколом, необхідно буде пам'ятати про нього та розширювати протокол 
за потребою.

Можна піти іншим шляхом та скористатися одним із стандартних протоколів. За такого підходу можна зекономити, 
використовуючи готове та протестоване рішення.

Python надає декілька модулів для серіалізації, найпопулярнішими з яких є pickle і json.
- вбудований пакет pickle дозволяє працювати з вбудованими типами (словники, списки, кортежі, рядки, множини та ін.) 
і навіть з нескладними класами;
- формат JSON підтримується Python і з невеликими обмеженнями дозволяє працювати з рядками, числами, списками, 
кортежами та словниками.

Обидва ці методи мають свої переваги та обмеження. Pickle має високу гнучкість і дозволяє серіалізувати складні 
об'єкти, але може бути небезпечним при десеріалізації даних зі сторонніх джерел. JSON є більш обмеженим у типах 
даних, які можуть бути серіалізовані, але забезпечує кращу багатоплатформову сумісність і безпеку.


                        Серіалізація об'єктів Python за допомогою pickle


Для виконання серіалізації та десеріалізації об'єктів важлива швидкість, коректність і невеликий розмір пам'яті, 
який при цьому використовується, і тут найкраще підійде пакет pickle.

Модуль pickle дозволяє серіалізувати об'єкти Python у потік байтів та десеріалізувати потік байтів назад у об'єкти. 
Це виправдано та корисно для зберігання об'єктів у файлах або передачі даних через мережу.

Основна мета pickle — зберегти стан об'єкта так, щоб його можна було точно відновити пізніше і часто в іншому місці.

У пакета pickle є дві пари парних методів:


                        Упакування у byte-рядки та розпакування із byte-рядків

Метод dumps запаковує в byte-рядок об'єкт, а метод loads потім розпаковує назад з byte-рядка в об'єкт. Ці методи 
потрібні, коли ми хочемо контролювати, що робити з byte представленням, наприклад, відправити його мережею або 
прийняти з мережі."""
import pickle

# Об'єкт для серіалізації
my_data = {"key": "value", "num": 42}

# Серіалізація об'єкта в байтовий рядок
serialized_data = pickle.dumps(my_data)
# Виведе байтовий рядок
print(serialized_data)  

# Десеріалізація об'єкта з байтового рядка
deserialized_data = pickle.loads(serialized_data)
# Виведе вихідний об'єкт Python
print(deserialized_data)

""" Виведення:
b'\\x80\\x04\\x95\\x1b\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x03key\\x94\\x8c\\x05value\\x94\\x8c\\x03num\\x94K*u.'
{'key': 'value', 'num': 42}

У цьому прикладі метод pickle.dumps(data) перетворює словник data в серіалізований байтовий рядок 
serialized_data. Далі pickle.loads(serialized_data) перетворює байтовий рядок назад в об'єкт Python, дозволяючи вам 
працювати з ним як зі звичайним словником. 


                        Упакування у файл та розпакування з файлу

Серіалізація у файл і десеріалізація з файлу дозволяють безпосередньо зберігати та відновлювати об'єкти у файловій 
системі. За це відповідають методи dump та load, що упаковують дані у файл та розпаковують із файлу відповідно.

Використання pickle.dump(data, file) зберігає об'єкт data у файлі data.pickle."""

import pickle

# Об'єкт для серіалізації
my_data = {"key": "value", "num": 100}

# Серіалізація об'єкта в файл
with open("data.pickle", "wb") as file:
    pickle.dump(my_data, file)

""" Після виконання коду ми збережемо словник **data** у файл. Тепер якщо нам знадобляться ці данні ми можемо 
виконати десеріалізацію даних з цього файлу, наприклад в іншому скрипті:"""

import pickle

# Десеріалізація об'єкта з файлу
with open('data.pickle', 'rb') as file:
    deserialized_data = pickle.load(file)

# Виведе вихідний об'єкт Python
print(deserialized_data)

""" Метод pickle.load(file) читає та відновлює об'єкт з файлу data.pickle. І ми в змінній deserialized_data 
отримаємо словник з тими ж значеннями, що і в попередньому прикладі у словника data.

{'key': 'value', 'num': 100}


                        Робота з класами користувача



Ви можете зберігати об'єкти для подальшого використання, але є важлива умова. Самі класи та функції pickle 
зберігати не вміє і, якщо вам потрібно розпакувати упакований об'єкт класу, то сам клас повинен бути оголошений 
раніше у коді.

Серіалізуємо екземпляр класу Human:"""

import pickle

class Human:
    def __init__(self, name):
        self.name = name

bob = Human("Bob")
with open("instance.pickle", "wb") as file:
    pickle.dump(bob, file)

"""Важливо, щоб клас Human був визначений у скрипті, який виконує десеріалізацію, із тією ж структурою та в тому ж 
просторі імен, що й у скрипті, який виконав серіалізацію."""

import pickle

class Human:
    def __init__(self, name):
        self.name = name

with open("instance.pickle", "rb") as file:
    loaded_instance = pickle.load(file)

print(loaded_instance.name)

# Виведення: Bob
"""
Якщо при десеріалізації не вказати клас Human ми отримаємо помилку.

import pickle

with open("instance.pickle", "rb") as file:
    loaded_instance = pickle.load(file)

print(loaded_instance.name)



Виведення буде про неможливість десеріалізувати клас Human:

Traceback (most recent call last):
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic8\\ex_pickle\\ex06.py", line 4, in <module>
    loaded_instance = pickle.load(file)
AttributeError: Can't get attribute 'Human' on <module '__main__' from 'E:\\\\WebDir\\\\Works\\\\Python\\\\python-help-solution\\\\core_course\\\\topic8\\\\ex_pickle\\\\ex06.py'>

Ми бачимо, що серіалізація дозволяє зберегти стан об'єкта на даний момент для подальшого використання, але в яких 
сценаріях це використовується?

Одна із розповсюджених практик це збереження налаштувань програми. Якщо ваша програма дозволяє користувачам 
налаштовувати різні параметри, ви можете серіалізувати ці налаштування в файл і десеріалізувати їх при наступному 
запуску програми для користувача."""

# Збереження налаштувань
settings = {'theme': 'dark', 'language': 'ukrainian'}
with open('settings.pickle', 'wb') as f:
    pickle.dump(settings, f)

# Завантаження налаштувань
with open('settings.pickle', 'rb') as f:
    loaded_settings = pickle.load(f)
    
print(loaded_settings)

""" Також серіалізація може бути використана для кешування складних обчислень. Уявимо, що обчислення займають 
багато часу, і інколи нам необхідно переривати виконання обчислень. Можна зберегти результати в серіалізованому 
вигляді і швидко відновити їх при наступній ітерації обчислень.

В веб розробці pickle найчастіше застосовується при передачі об'єктів між різними частинами програми, які працюють 
як окремі процеси, або між програмами, які виконуються на різних комп'ютерах у мережі.

Також інколи складні структури даних не вписуються в стандартні типи даних баз даних. В такому випадку, 
серіалізація дозволяє перетворити ці структури в байтові рядки, які можна зберігати як текст або BLOB (Binary Large 
Object) у базі даних.


                        Серіалізація об'єктів Python за допомогою JSON


JSON, або JavaScript Object Notation, є текстовим форматом для представлення структурованих даних на основі 
синтаксису об'єктів мови програмування JavaScript.

Хоча він був розроблений для JavaScript, його легко читають і генерують багато мов програмування, що робить JSON 
дуже популярним для обміну даними між клієнтами та серверами, веб-застосунками. Він широко використовується для 
зберігання конфігурацій, серіалізації даних в файлових системах та як формат обміну даними між різними мовами 
програмування, завдяки його простоті та підтримці багатьма бібліотеками.

JSON пропонує просту і зрозумілу структуру. Він представляє дані як набір ключ-значення, де ключі є рядками, а 
значення можуть бути рядками, числами, масивами, логічними значеннями або навіть іншими об'єктами. Це дозволяє 
легко представляти складні структури даних, такі як списки, словники та ієрархічні дерева.

Головна перевага JSON полягає в тому, що він дозволяє представляти дані у форматі, який є легким для людини, щоб 
читати та писати його навіть вручну.

Синтаксис JSON базується на двох структурних елементах: об'єкти та масиви.

У JSON, об'єкти представляються у вигляді пар "ключ-значення" і огортаються у фігурні дужки {}. Ключі мають бути 
рядками (текстом у подвійних лапках), а значення можуть бути рядками, числами, масивами, логічними значеннями, 
іншими об'єктами або навіть значенням null (це значення None для Python). Кожна пара "ключ-значення" відділяється 
комою.

Наприклад:
{
  "name": "Gupalo Vasyl",
  "age": 30,
  "isStudent": true
}

Тут ми бачимо об'єкт з трьома полями: ім'я name, вік age і статус студента isStudent. Не забуваємо, що JSON прийшов 
до нас з JavaScript і логічні значення там з маленької літери: true та false. А так все досить схоже на наш словник.

Масиви в JSON представляються послідовністю значень, огорнутих у квадратні дужки []. Значення в масиві теж можуть 
бути рядками, числами, об'єктами, іншими масивами, логічними значеннями або null, і вони відділяються одне від 
одного комами.

Наприклад:
["apple", "banana", "cherry"]

Це масив з трьома рядковими елементами, які представляють назви фруктів. Фактично це наш список з рядками.

Python підтримує формат JSON та в стандартному постачанні включає в себе пакет json, в якому є все необхідне для 
роботи. Ця бібліотека дозволяє легко серіалізувати об'єкти Python у формат JSON та десеріалізувати рядки JSON назад 
у Python об'єкти. Розглянемо детально, як це працює.

Серіалізація (або "запис") перетворює об'єкти Python у рядок у форматі JSON. Це виконується за допомогою методу 
json.dumps() для перетворення об'єктів у рядок JSON.

Метод dumps запаковує в byte-рядок об'єкт, loads розпаковує (десеріалізує) з byte-рядка в об'єкт. Ці методи 
потрібні, коли ми хочемо контролювати, що робити з byte представленням, наприклад, відправити його мережею або 
прийняти з мережі."""

import json

some_data = {
    "key": "value",
    2: [1, 2, 3],
    "my_tuple": (5, 6),
    "my_dict": {"key": "value"},
}

json_string = json.dumps(some_data)
print(json_string)
unpacked_some_data = json.loads(json_string)
print(unpacked_some_data)
"""
Виведення:
{"key": "value", "2": [1, 2, 3], "my_tuple": [5, 6], "my_dict": {"key": "value"}}
{'key': 'value', '2': [1, 2, 3], 'my_tuple': [5, 6], 'my_dict': {'key': 'value'}}

В цьому прикладі запакований в json_string словник some_data розпакований в unpacked_some_data . Можна побачити, 
що unpacked_some_data не дорівнює some_data, і ми не отримали той самий об'єкт. Хоча JSON і Python мають схожу 
структуру даних, є деякі відмінності. Як бачимо, JSON не розрізняє кортежі та списки, обидва типи в Python будуть 
конвертовані у масиви JSON. Окрім того ключ ціле число 2 був неявно перетворений на рядок '2'.

Кодування об’єктів Python у формат JSON відбувається за наступними правилами:

- Модуль json перетворює dict в об’єкти JSON,
- Список і кортеж перетворюються в масив JSON.
- Рядок Python перетворюється на рядок JSON.
- Цілі числа та дійсні числа перетворюються на числа JSON.
- Логічне значення True перетворюється на константу JSON true.
- Логічне значення False перетворюється на константу JSON false.
- None перетворюється на константу JSON null.

Насправді для вирішення цих та інших специфічних задач, бібліотека json дозволяє використовувати додаткові 
параметри default та object_hook для нестандартної серіалізації та десеріалізації. Але ми не будемо акцентувати 
увагу на цих специфічних задачах, а розглянемо більш актуальну роботу з файлами.

Серіалізація об'єкта Python у рядок формату JSON виконується за допомогою методу json.dump(), якщо потрібно 
записати JSON безпосередньо у файл."""

import json

# Python об'єкт (словник)
data = {"name": "Gupalo Vasyl", "age": 30, "isStudent": True}

# Серіалізація у файл
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f)
"""
Після виконання коду, в тій же директорії де знаходиться скрипт, ми повинні отримати файл data.json з наступним 
вмістом:

{"name": "Gupalo Vasyl", "age": 30, "isStudent": true}

Десеріалізація перетворює рядок у форматі JSON назад у відповідні об'єкти Python. Це виконується за допомогою 
методу json.load(), якщо JSON читається безпосередньо з файлу."""

import json

# Десеріалізація з файлу
with open("data.json", "r", encoding="utf-8") as f:
    data_from_file = json.load(f)
    print(data_from_file)

# Виведення: {'name': 'Gupalo Vasyl', 'age': 30, 'isStudent': True}

""" В принципі немає ніякої складності з допомогою бібліотеки json виконувати гнучке перетворення між форматами, 
адаптуючи серіалізацію та десеріалізацію під конкретні потреби нашої програми.

Проблема може виникнути тільки при записі у файл JSON кирилиці або будь-яких інших не ASCII символів. Тому важливо 
забезпечити правильне кодування символів, щоб уникнути проблем з читанням файлу та його сумісністю. Python за 
замовчуванням використовує кодування UTF-8, яке підтримує кирилицю, але при записі в JSON нам необхідно вказати 
додаткові параметри для забезпечення коректного відображення символів. По що мова? Глянемо наступний приклад."""

import json

# Python об'єкт (словник)
data = {"name": "Гупало Василь", "age": 30, "isStudent": True}

# Серіалізація у файл
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f)
    
print("Data saved to data.json")

"""Тут в словнику data, як значення для ключа name ми маємо рядок "Гупало Василь", який записаний символами 
кирилиці. Якщо ми заглянемо в файл data.json то побачимо наступне:"""

# {
#   "name": "\\u0413\\u0443\\u043f\\u0430\\u043b\\u043e \\u0412\\u0430\\u0441\\u0438\\u043b\\u044c",
#   "age": 30,
#   "isStudent": true
# }

# """Як бачимо замість рядка "Гупало Василь" в нас набір Unicode escape-послідовностей. Кожна escape-послідовність 
# починається з \u , за яким слідує чотири шістнадцяткових цифр, які представляють символ у Unicode.

# Ось як можна це виправити та записати дані в файл JSON, використовуючи кирилицю:"""

import json

# Python об'єкт (словник)
data = {"name": "Гупало Василь", "age": 30, "isStudent": True}

# Серіалізація у файл
with open("data.json", "w", encoding="utf-8") as f:
    json.dump(data, f, ensure_ascii=False, indent=4)

"""
Ми використали два важливих параметри json.dump функції:
    - ensure_ascii=False гарантує, що символи кирилиці будуть записані як є, без перетворення в їхні Unicode 
    escape-послідовності.
    - indent=4 забезпечує форматування виведення, роблячи JSON файл легшим для читання людиною за допомогою 
    відступів.

Тепер файл data.json матиме наступний вигляд:
  {
    "name": "Гупало Василь",
    "age": 30,
    "isStudent": true
}
Десеріалізація при цьому виконується, як і раніше.
"""