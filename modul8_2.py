"""                                         Управління порядком серіалізації та копіювання об'єктів

                        Управління порядком серіалізації


Нагадаємо, що серіалізація - це процес перетворення об'єкта у потік байтів для зберігання або передачі. Десеріалізація - 
зворотний процес, коли потік байтів перетворюється назад у об'єкт. Але не всі об'єкти Python можна серіалізувати. Наприклад, 
не можна серіалізувати файловий дескриптор або системний ресурс. Тоді, що робити, коли є клас, об'єкт який треба запакувати, 
використовуючи pickle, але у нього є атрибути, що не серіалізуються? У такій ситуації можна скористатися магічними методами, 
які управляють серіалізацією та десеріалізацією за допомогою pickle.

Методи __getstate__ і __setstate__ в Python дозволяють нам контролювати, як об'єкт повинен бути серіалізований та 
десеріалізований модулем pickle.

Коли викликається pickle.dump() або pickle.dumps() для серіалізації об'єкта, Python шукає метод __getstate__ у класі об'єкта. 
Якщо метод існує, він використовується для отримання стану об'єкта для серіалізації. При десеріалізації, за допомогою 
pickle.load() або pickle.loads(), Python шукає метод __setstate__ у класі. Якщо метод існує, він використовується для 
відновлення стану об'єкта з даних, отриманих під час десеріалізації.

Припустимо, у нас є клас Robot, який містить інформацію про робота, але ми хочемо серіалізувати лише певні атрибути."""

import pickle

class Robot:
    def __init__(self, name, battery_life):
        self.name = name
        self.battery_life = battery_life
        # Цей атрибут ми не збираємось серіалізувати
        self.is_active = False  

    def __getstate__(self):
        state = self.__dict__
        # Видаляємо is_active з серіалізованого стану
        del state['is_active']
        return state

    def __setstate__(self, state):
        # Відновлюємо об'єкт при десеріалізації
        self.__dict__.update(state)
        # Задаємо значення is_active за замовчуванням
        self.is_active = False  

# Створення об'єкта Robot
robot = Robot("Robo1", 100)

# Серіалізація об'єкта
serialized_robot = pickle.dumps(robot)

# Десеріалізація об'єкта
deserialized_robot = pickle.loads(serialized_robot)

print(deserialized_robot.__dict__)

# Виведення:
# {'name': 'Robo1', 'battery_life': 100, 'is_active': False}

"""Це досить штучний приклад, де __getstate__ модифікує стан об'єкта перед серіалізацією, видаляючи атрибут is_active, 
тому що ми вирішили, що цей атрибут не потрібно зберігати. Метод __setstate__ відновлює стан об'єкта при десеріалізації, 
встановлюючи is_active назад на значення за замовчуванням, оскільки цей атрибут не був збережений.

Для цих операцій ми використовуємо self.__dict__, який є спеціальним атрибутом об'єкта, що містить словник з усіма атрибутами, 
які належать до цього об'єкта. Ключі у цьому словнику відповідають іменам атрибутів, а значення — це відповідні значення цих 
атрибутів. Коли ми створюємо новий екземпляр класу, Python автоматично створює словник __dict__ для цього екземпляра, щоб 
зберігати всі атрибути, які додаються до цього об'єкта.

Пояснимо на простому прикладі, маємо простий клас:"""
class Example:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Коли ми створюємо екземпляр цього класу:

obj = Example("Gupalo Vasyl", 30)

# То obj.__dict__ міститиме:
# {'name': 'Gupalo Vasyl', 'age': 30}
# Ми можемо динамічно додавати, видаляти або змінювати атрибути:

obj.__dict__['city'] = 'Poltava'  # Додавання нового атрибута
print(obj.city)  # Виведення: Poltava

del obj.__dict__['age']  # Видалення атрибута age
print(obj.__dict__)  # Виведення: {'name': 'Gupalo Vasyl', 'city': 'Poltava'}

""" Однак, це слід робити дуже обережно, оскільки необдумані зміни можуть призвести до непередбачуваної поведінки 
об'єкта. У нашому прикладі, ми використовуємо self.__dict__ для копіювання всіх атрибутів об'єкта Robot при реалізації 
методів __getstate__ і __setstate__, що дозволяє зберігати і відновлювати стан об'єкта при роботі з модулем pickle.

Більш практично ця техніка використовується для об'єктів, що містять несеріалізовані атрибути, такі як відкриті файли 
або з'єднання з базами даних. Розглянемо наступний приклад, який визначає клас Reader для читання даних з файлу. Клас 
простий, з методами для ініціалізації та закриття файлового дескриптора, а також методом для читання вмісту файлу."""

class Reader:
    def __init__(self, filename):
        self.filename = filename
        self.fh = open(self.filename, "r", encoding="utf-8")

    def close(self):
        self.fh.close()

    def read(self):
        data = self.fh.read()
        return data

if __name__ == "__main__":
    reader = Reader("data.txt")
    data = reader.read()
    print(data)
    reader.close()

# Якщо створити текстовий файл "data.txt", наприклад з рядком тексту "Message from file", то виведення буде наступним.
# Message from file

""" Однак, є важлива особливість стосовно використання цього класу з бібліотеками серіалізації, такими як pickle. Якщо
ми захочемо серіалізувати наш об'єкт reader то отримаємо помилку.

import pickle

class Reader:
    def __init__(self, filename):
        self.filename = filename
        self.fh = open(self.filename, "r", encoding="utf-8")

    def close(self):
        self.fh.close()

    def read(self):
        data = self.fh.read()
        return data

if __name__ == "__main__":
    reader = Reader("data.txt")
    # Приклад серіалізації об'єкта Reader
    with open("reader.pkl", "wb") as f:
        pickle.dump(reader, f)

При намаганні серіалізувати екземпляр класу Reader за допомогою pickle, виникає помилка, оскільки файловий дескриптор 
self.fh не може бути серіалізованим. Вона виникає тому, що файлові дескриптори не підлягають серіалізації pickle через 
їх залежність від зовнішніх системних ресурсів, які pickle не може зберегти та відновити.

Traceback (most recent call last):
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic8\\ex_pickle\\ex09.py", line 21, in <module>
    pickle.dump(reader, f)
TypeError: cannot pickle '_io.TextIOWrapper' object

Для того, щоб зробити екземпляри класу Reader серіалізованими, нам необхідно реалізувати методи __getstate__ та __setstate__ 
та керувати поведінкою pickle для класу. Це дозволить нам явно визначити, яка частина об'єкта має бути серіалізована, та як 
об'єкт має бути відновлений.

У наступному прикладі клас Reader можна серіалізувати і помилки через неможливість упакувати файловий дескриптор вже не виникне."""

import pickle

class Reader:
    def __init__(self, filename):
        self.filename = filename
        self.fh = open(self.filename, "r", encoding="utf-8")

    def close(self):
        self.fh.close()

    def read(self):
        data = self.fh.read()
        return data

    def __getstate__(self):
        attributes = {**self.__dict__, "fh": None}
        return attributes

    def __setstate__(self, state):
        # Відновлюємо стан об'єкта
        self.__dict__ = state
        self.fh = open(state["filename"], "r", encoding="utf-8")

if __name__ == "__main__":
    reader = Reader("data.txt")
    data = reader.read()
    print(data)
    reader.close()

    # Приклад серіалізації об'єкта Reader
    with open("reader.pkl", "wb") as f:
        pickle.dump(reader, f)

    # Приклад десеріалізації об'єкта Reader
    with open("reader.pkl", "rb") as f:
        loaded_reader = pickle.load(f)
        print(loaded_reader.read())
        loaded_reader.close()

""" У цій модифікованій версії, метод __getstate__ створює копію словника атрибутів об'єкта з self.__dict__, але 
замінює fh на None, щоб уникнути спроби серіалізації відкритого файлового дескриптора.

    ☝ Файловий дескриптор self.fh не включений до стану, тому що він не може бути серіалізованим.

Метод __setstate__ відновлює стан об'єкта зі стану, отриманого при десеріалізації, і відкриває файл знову, 
використовуючи збережене ім'я файлу. 

Це дозволяє нам знову отримати доступ до вмісту файлу після десеріалізації.

Загалом наша реалізація ефективно вирішує проблему з неможливістю серіалізації файлових дескрипторів і дозволяє 
безпечно зберігати та відновлювати стан об'єктів, що працюють з файлами.


                        Створення копій об'єктів в Python


Створення копій об'єктів у Python може виявитися нетривіальним завданням, залежно від того, чи потрібна вам поверхнева 
(shallow) або глибока (deep) копія, а також від складності структури даних об'єкта.

Python намагається заощаджувати пам'ять і не копіювати дані з однієї області пам'яті в іншу. Натомість інтерпретатор створює 
нове посилання, це ще один псевдонім, на реальний об'єкт, замість копіювання вмісту. Така поведінка може бути небажаною, 
розглянемо наприклад:"""

my_list = [1, 2, 3]
copy_list = my_list
copy_list.append(4)
print(my_list)

# Виведення:
# [1, 2, 3, 4]

""" Виходить, що copy_list — це просто ще одне ім'я для того самого списку my_list і, змінюючи copy_list, ми змінюємо й my_list. 
Це неочевидно і може збивати з пантелику.

Така поведінка може призводити до помилок, коли справа стосується типів, словників, списків, класів користувача, що змінюються.

Розглянемо приклад де ми передаємо список в середину функції, а вона його змінює:"""

my_list = [1, 2, 3]

def square_list(x: list):
    for i, el in enumerate(x):
        x[i] = el**2
    return x

new_list = square_list(my_list)
print(new_list)
print(my_list)

# Виведення:
# [1, 4, 9]
# [1, 4, 9]

""" Як бачимо список my_list зазнав змін, і можливо це зовсім небажана поведінка. У прикладі функція square_list 
приймає список x як аргумент і модифікує його, підносячи кожен елемент до квадрату. Виходить, що функція змінює вхідний 
список без створення нового списку. Тому коли ми передали my_list в square_list, оригінальний список my_list змінюється.

Якщо нам потрібно зберегти оригінальний список my_list без змін і створити новий список з квадратами елементів, то слід 
створити копію списку перед його зміною або змінити функцію, щоб вона повертала новий список з квадратами елементів, замість 
зміни вхідного списку. Наприклад:"""

my_list = [1, 2, 3]

def square_list(x: list):
    return [el**2 for el in x]

new_list = square_list(my_list)
print(new_list)
print(my_list)

# Виведення:
# [1, 4, 9]
# [1, 2, 3]

# Як бачимо, оригінальний список my_list тепер залишається без змін.

# Для списків та словників можна скористатися явним копіюванням:

my_list = [1, 2, 3]
copy_list = my_list[:]
copy_list.append(4)
print(my_list, copy_list)

my_dict = {1: "a"}
copy_dict = {**my_dict}
copy_dict["new_key"] = "new_value"
print(my_dict, copy_dict)

""" Інструкція copy_list = my_list[:] створює новий список copy_list, який є поверхневою копією my_list. Модифікація 
copy_list, як додавання елемента 4 не впливає тепер на список my_list. При створені словника copy_dict = {**my_dict} 
використовується синтаксис розпакування словника **, щоб створити новий словник copy_dict, який є копією my_dict. 

Тепер любі модифікації copy_dict, як наприклад додавання пари ключ-значення "new_key": "new_value" не впливають на 
початковий словник my_dict.

Тому виведення буде:
[1, 2, 3] [1, 2, 3, 4]
{1: 'a'} {1: 'a', 'new_key': 'new_value'}

Обидва наші приклади ілюструють як через зріз для списків або розпакування для словників отримати новий, незалежний 
об'єкт. Але з об’єктами класів та типами користувача так легко, це не зробиш. Щоб вирішити цю проблему, у Python є 
механізм копіювання — це функції із пакету copy.


                        Створення поверхневих копій об'єктів Python


Щоб створити "поверхневу" копію об'єкта, у пакеті copy є функція copy. Ця функція створює новий об'єкт такого самого типу 
і потім створює посилання на увесь вміст старого об'єкта в новий. Такий механізм досить хороший для роботи з об'єктами, де 
вже на першому рівні вкладеності немає змінних об'єктів, і він працює досить швидко."""

import copy

my_list = [1, 2, {"name": "Gupalo Vasyl"}]
copy_list = copy.copy(my_list)
copy_list.append(4)
print(my_list)
print(copy_list)

# Виведення:
# [1, 2, {'name': 'Gupalo Vasyl'}]
# [1, 2, {'name': 'Gupalo Vasyl'}, 4]

""" Поверхнева копія означає, що новий список copy_list буде містити нові посилання на ті ж самі об'єкти, що і оригінальний 
список і для об'єктів із глибокою вкладеністю така функція все ж таки не дасть потрібного ефекту. Тому вкладені об'єкти, такі 
як словник в третьому елементі списку, будуть спільними між оригінальним та скопійованим списками."""

import copy

my_list = [1, 2, {"name": "Gupalo Vasyl"}]
copy_list = copy.copy(my_list)
copy_list[2]["age"] = 30
print(my_list)
print(copy_list)

# Виведення:
# [1, 2, {'name': 'Gupalo Vasyl', 'age': 30}]
# [1, 2, {'name': 'Gupalo Vasyl', 'age': 30}]

""" З цього прикладу видно, що хоча copy_list вже є новим об'єктом, але вкладений у нього словник з індексом 2 — це один 
і той самий словник і в copy_list, і в my_list.

    ☝ Поверхнева копія створює новий об'єкт, але не копіює вкладені об'єкти. Замість цього, вона копіює лише посилання на 
    вкладені об'єкти. Це означає, що якщо ви змінюєте вкладені об'єкти в оригіналі, ці зміни також відобразяться у поверхневій 
    копії.


                        Створення глибоких копій об'єктів Python


Глибока копія створює новий об'єкт та рекурсивно копіює всі вкладені об'єкти. В результаті, ви отримуєте повністю незалежну 
копію оригінального об'єкта.

Для створення глибокої копії використовуйте метод deepcopy() модуля copy. Ця функція рекурсивно створює нові об'єкти."""

import copy

my_list = [1, 2, {"name": "Gupalo Vasyl"}]
copy_list = copy.deepcopy(my_list)
copy_list[2]["age"] = 30
print(my_list)
print(copy_list)

# Виведення:
# [1, 2, {'name': 'Gupalo Vasyl'}]
# [1, 2, {'name': 'Gupalo Vasyl', 'age': 30}]

""" Залежно від задачі, вам може бути достатньо використати поверхневу копію, або може знадобитися глибока копія для 
забезпечення повної незалежності даних. Головне розуміти структуру та залежності даних у вашому об'єкті, щоб обрати 
правильний метод копіювання.


                        Управління порядком копіювання об'єктів Python


Ще одна проблема, яка вирішується за допомогою пакета copy — це копіювання об'єктів користувача.

Щоб створити об'єкт, який буде коректно оброблятися функціями copy та deepcopy, заданий клас повинен реалізувати два 
магічних методи: __copy__ та __deepcopy__ для поверхневого та глибокого копіювання відповідно.

Коли викликаємо copy.copy() або copy.deepcopy() на об'єкті, Python автоматично шукає і викликає ці магічні методи в класі 
об'єкта, якщо вони визначені.



    - __copy__ повинен повертати поверхневу копію об'єкта.
    - __deepcopy__ повинен повертати глибоку копію об'єкта. Він приймає додатковий аргумент memo, який є словником, що 
    використовується для уникнення нескінченної рекурсії при копіюванні вкладених об'єктів, які посилаються самі на себе.

Спочатку розглянемо простий приклад класу, який реалізує обидва ці методи:"""

import copy

class MyClass:
    def __init__(self, value):
        self.value = value

    def __copy__(self):
        print("Викликано __copy__")
        return MyClass(self.value)

    def __deepcopy__(self, memo=None):
        print("Викликано __deepcopy__")
        return MyClass(copy.deepcopy(self.value, memo))

# Поверхневе копіювання
obj = MyClass(5)
obj_copy = copy.copy(obj)
obj_copy.value = 10

# Глибоке копіювання
obj_deepcopy = copy.deepcopy(obj)
obj_deepcopy.value = 20
print(obj.value, obj_copy.value, obj_deepcopy.value)

""" У нашому прикладі, при виклику copy.copy(obj) буде створено новий екземпляр MyClass з тим же значенням value. 
При виклику copy.deepcopy(obj) також буде створено новий екземпляр, але з використанням copy.deepcopy для значення 
value, що забезпечує глибоке копіювання будь-яких вкладених об'єктів.

Виведення:
Викликано __copy__
Викликано __deepcopy__
5 10 20

Як бачимо все працює вірно. Із не розглянутого тут тільки те, що __deepcopy__ використовує словник memo. Словник memo 
використовується для відстеження об'єктів, які вже були скопійовані під час поточної операції глибокого копіювання.

Коли __deepcopy__ викликається для об'єкта, він перевіряє, чи існує вже копія цього об'єкта в словнику memo. Якщо так, 
метод повертає посилання на вже скопійований об'єкт замість створення нової копії. Це запобігає створенню кількох копій 
одного і того ж об'єкта під час глибокого копіювання та уникненню нескінченної рекурсії.

У словнику memo ключами є ідентифікатори id об'єктів, а значеннями є вже скопійовані об'єкти. Це дозволяє швидко перевірити, 
чи був об'єкт уже оброблений під час поточної операції копіювання.

Тепер розглянемо більш складний приклад з вкладеними об'єктами:"""

import copy

class SimpleObject:
    def __init__(self, greeting: str):
        self.greeting = greeting

class ComplexObject:
    def __init__(self, value: int, nested_obj: SimpleObject):
        self.value = value
        self.nested_obj = nested_obj

    def __copy__(self):
        print("Викликано __copy__ для ComplexObject")
        # Поверхневе копіювання не копіює вкладені об'єкти глибоко
        return ComplexObject(self.value, self.nested_obj)

    def __deepcopy__(self, memo=None):
        print("Викликано __deepcopy__ для ComplexObject")
        # Глибоке копіювання копіює вкладені об'єкти
        return ComplexObject(
            copy.deepcopy(self.value, memo), copy.deepcopy(self.nested_obj, memo)
        )

nested_obj = SimpleObject("Привіт")
complex_obj = ComplexObject(5, nested_obj)

# Створюємо копію та глибоку копію
complex_obj_copy = copy.copy(complex_obj)
complex_obj_deepcopy = copy.deepcopy(complex_obj)

# Змінюємо значення вкладеного об'єкту nested_obj
nested_obj.greeting = "Hello"

# Дивимось зміни у об'єктах
print(f"Copy object: {complex_obj_copy.nested_obj.greeting}")
print(f"Deepcopy object: {complex_obj_deepcopy.nested_obj.greeting}")

# Виведення:
# Викликано __copy__ для ComplexObject
# Викликано __deepcopy__ для ComplexObject
# Copy object: Hello
# Deepcopy object: Привіт

""" У цьому прикладі, ComplexObject містить вкладений об'єкт класу SimpleObject. При поверхневому копіюванні __copy__, 
вкладений об'єкт self.nested_obj не копіюється глибоко, тому коли ми вносимо зміни в оригінальному об'єкті nested_obj 
вони вплинуть і на копію, що ми і бачимо в виведенні. При глибокому копіюванні __deepcopy__, вкладений об'єкт self.nested_obj 
також копіюється глибоко, завдяки чому копія є повністю незалежною від оригіналу.

Насправді, навіть без реалізації цих магічних методів все працюватиме як треба."""

import copy

class SimpleObject:
    def __init__(self, greeting: str):
        self.greeting = greeting

class ComplexObject:
    def __init__(self, value, nested_obj: SimpleObject):
        self.value = value
        self.nested_obj = nested_obj

nested_obj = SimpleObject("Привіт")
complex_obj = ComplexObject(5, nested_obj)

# Створюємо копію та глибоку копію
complex_obj_copy = copy.copy(complex_obj)
complex_obj_deepcopy = copy.deepcopy(complex_obj)

# Змінюємо значення вкладеного об'єкту nested_obj
nested_obj.greeting = "Hello"

# Дивимось зміни у об'єктах
print(f"Copy object: {complex_obj_copy.nested_obj.greeting}")
print(f"Deepcopy object: {complex_obj_deepcopy.nested_obj.greeting}")

# Виведення:
# Copy object: Hello
# Deepcopy object: Привіт

""" Мета було пояснити, як у Python можна налаштувати процеси поверхневого та глибокого копіювання об'єктів за 
допомогою реалізації спеціальних методів __copy__ та __deepcopy__. Це дозволяє контролювати, як саме об'єкти клонуються, 
коли використовуються функції copy() та deepcopy() з модуля copy та важливо для класів, які містять складні вкладені 
структури або залежності.

Наприклад, якщо наш об'єкт містить великі дані і вони не повинні бути дубльовані при копіюванні, то налаштування __deepcopy__ 
дозволяє нам контролювати процес клонування. Це допомагає уникнути небажаного дублювання та забезпечує коректне копіювання 
складних структур.

Уявімо, що ми працюємо з класом, який представляє налаштування користувача, і ці налаштування включають в себе великий 
набір даних (гігабайти даних), який не потрібно дублювати при кожному копіюванні, але з яким потрібно працювати в 
ізольованому середовищі."""

import copy

class UserSettings:
    def __init__(self, preferences, large_data_reference):
        self.preferences = preferences
        self.large_data_reference = large_data_reference

    def __deepcopy__(self, memo):
        print("Кастомізоване глибоке копіювання для UserSettings")
        # Припустимо, що preferences - це невеликий словник, який можна безпечно скопіювати,
        # а large_data_reference - це посилання на великий об'єкт даних, яке ми не хочемо дублювати.
        new_preferences = copy.deepcopy(self.preferences, memo)
        # Передаємо посилання на ті ж великі дані замість їх копіювання
        new_obj = UserSettings(new_preferences, self.large_data_reference)
        return new_obj

# Створення екземпляра UserSettings
original_settings = UserSettings({"language": "uk"}, large_data_reference="LargeDataID")

# Глибоке копіювання з кастомізованою логікою
settings_copy = copy.deepcopy(original_settings)

""" Ми можемо налаштувати метод __deepcopy__ таким чином, що він дозволяє ефективно копіювати налаштування користувача, 
не створюючи непотрібні копії великих об'єктів даних, до яких має бути лише посилання. Бо якщо ми тільки читаємо дані 
об'єкту self.large_data_reference то взагалі немає необхідності дублювання цих даних при глибокому копіюванні. Такий 
підхід дозволяє оптимізувати використання пам'яті та час виконання програми, зберігаючи при цьому необхідну гнучкість 
у роботі з копіями об'єктів.

                        Підсумки модуля
                        
Цей модуль, а з ним і весь блок Python Core завершено. Вітаємо!

Ми вивчили, зо таке серіалізація, та як працює передача даних в Python.

Тепер ти знаєш, що таке:
- Серіалізація об'єктів Python
- Серіалізація об'єктів за допомогою pickle
- Серіалізація за допомогою JSON
- Робота з таблицями CSV
- Управління порядком серіалізації
- Створення копій об'єктів
- Створення поверхневих копій об'єктів
- Управління порядком копіювання об'єктів Python
"""