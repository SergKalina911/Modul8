"""                                         Управління порядком серіалізації та копіювання об'єктів

                        Управління порядком серіалізації


Нагадаємо, що серіалізація - це процес перетворення об'єкта у потік байтів для зберігання або передачі. Десеріалізація - 
зворотний процес, коли потік байтів перетворюється назад у об'єкт. Але не всі об'єкти Python можна серіалізувати. Наприклад, 
не можна серіалізувати файловий дескриптор або системний ресурс. Тоді, що робити, коли є клас, об'єкт який треба запакувати, 
використовуючи pickle, але у нього є атрибути, що не серіалізуються? У такій ситуації можна скористатися магічними методами, 
які управляють серіалізацією та десеріалізацією за допомогою pickle.

Методи __getstate__ і __setstate__ в Python дозволяють нам контролювати, як об'єкт повинен бути серіалізований та 
десеріалізований модулем pickle.

Коли викликається pickle.dump() або pickle.dumps() для серіалізації об'єкта, Python шукає метод __getstate__ у класі об'єкта. 
Якщо метод існує, він використовується для отримання стану об'єкта для серіалізації. При десеріалізації, за допомогою 
pickle.load() або pickle.loads(), Python шукає метод __setstate__ у класі. Якщо метод існує, він використовується для 
відновлення стану об'єкта з даних, отриманих під час десеріалізації.

Припустимо, у нас є клас Robot, який містить інформацію про робота, але ми хочемо серіалізувати лише певні атрибути."""

import pickle

class Robot:
    def __init__(self, name, battery_life):
        self.name = name
        self.battery_life = battery_life
        # Цей атрибут ми не збираємось серіалізувати
        self.is_active = False  

    def __getstate__(self):
        state = self.__dict__
        # Видаляємо is_active з серіалізованого стану
        del state['is_active']
        return state

    def __setstate__(self, state):
        # Відновлюємо об'єкт при десеріалізації
        self.__dict__.update(state)
        # Задаємо значення is_active за замовчуванням
        self.is_active = False  

# Створення об'єкта Robot
robot = Robot("Robo1", 100)

# Серіалізація об'єкта
serialized_robot = pickle.dumps(robot)

# Десеріалізація об'єкта
deserialized_robot = pickle.loads(serialized_robot)

print(deserialized_robot.__dict__)

# Виведення:
# {'name': 'Robo1', 'battery_life': 100, 'is_active': False}

"""Це досить штучний приклад, де __getstate__ модифікує стан об'єкта перед серіалізацією, видаляючи атрибут is_active, 
тому що ми вирішили, що цей атрибут не потрібно зберігати. Метод __setstate__ відновлює стан об'єкта при десеріалізації, 
встановлюючи is_active назад на значення за замовчуванням, оскільки цей атрибут не був збережений.

Для цих операцій ми використовуємо self.__dict__, який є спеціальним атрибутом об'єкта, що містить словник з усіма атрибутами, 
які належать до цього об'єкта. Ключі у цьому словнику відповідають іменам атрибутів, а значення — це відповідні значення цих 
атрибутів. Коли ми створюємо новий екземпляр класу, Python автоматично створює словник __dict__ для цього екземпляра, щоб 
зберігати всі атрибути, які додаються до цього об'єкта.

Пояснимо на простому прикладі, маємо простий клас:"""
class Example:
    def __init__(self, name, age):
        self.name = name
        self.age = age

# Коли ми створюємо екземпляр цього класу:

obj = Example("Gupalo Vasyl", 30)

# То obj.__dict__ міститиме:
# {'name': 'Gupalo Vasyl', 'age': 30}
# Ми можемо динамічно додавати, видаляти або змінювати атрибути:

obj.__dict__['city'] = 'Poltava'  # Додавання нового атрибута
print(obj.city)  # Виведення: Poltava

del obj.__dict__['age']  # Видалення атрибута age
print(obj.__dict__)  # Виведення: {'name': 'Gupalo Vasyl', 'city': 'Poltava'}

""" Однак, це слід робити дуже обережно, оскільки необдумані зміни можуть призвести до непередбачуваної поведінки 
об'єкта. У нашому прикладі, ми використовуємо self.__dict__ для копіювання всіх атрибутів об'єкта Robot при реалізації 
методів __getstate__ і __setstate__, що дозволяє зберігати і відновлювати стан об'єкта при роботі з модулем pickle.

Більш практично ця техніка використовується для об'єктів, що містять несеріалізовані атрибути, такі як відкриті файли 
або з'єднання з базами даних. Розглянемо наступний приклад, який визначає клас Reader для читання даних з файлу. Клас 
простий, з методами для ініціалізації та закриття файлового дескриптора, а також методом для читання вмісту файлу."""

class Reader:
    def __init__(self, filename):
        self.filename = filename
        self.fh = open(self.filename, "r", encoding="utf-8")

    def close(self):
        self.fh.close()

    def read(self):
        data = self.fh.read()
        return data

if __name__ == "__main__":
    reader = Reader("data.txt")
    data = reader.read()
    print(data)
    reader.close()

# Якщо створити текстовий файл "data.txt", наприклад з рядком тексту "Message from file", то виведення буде наступним.
# Message from file

""" Однак, є важлива особливість стосовно використання цього класу з бібліотеками серіалізації, такими як pickle. Якщо
ми захочемо серіалізувати наш об'єкт reader то отримаємо помилку.

import pickle

class Reader:
    def __init__(self, filename):
        self.filename = filename
        self.fh = open(self.filename, "r", encoding="utf-8")

    def close(self):
        self.fh.close()

    def read(self):
        data = self.fh.read()
        return data

if __name__ == "__main__":
    reader = Reader("data.txt")
    # Приклад серіалізації об'єкта Reader
    with open("reader.pkl", "wb") as f:
        pickle.dump(reader, f)

При намаганні серіалізувати екземпляр класу Reader за допомогою pickle, виникає помилка, оскільки файловий дескриптор 
self.fh не може бути серіалізованим. Вона виникає тому, що файлові дескриптори не підлягають серіалізації pickle через 
їх залежність від зовнішніх системних ресурсів, які pickle не може зберегти та відновити.

Traceback (most recent call last):
  File "E:\\WebDir\\Works\\Python\\python-help-solution\\core_course\\topic8\\ex_pickle\\ex09.py", line 21, in <module>
    pickle.dump(reader, f)
TypeError: cannot pickle '_io.TextIOWrapper' object

Для того, щоб зробити екземпляри класу Reader серіалізованими, нам необхідно реалізувати методи __getstate__ та __setstate__ 
та керувати поведінкою pickle для класу. Це дозволить нам явно визначити, яка частина об'єкта має бути серіалізована, та як 
об'єкт має бути відновлений.

У наступному прикладі клас Reader можна серіалізувати і помилки через неможливість упакувати файловий дескриптор вже не виникне."""

import pickle

class Reader:
    def __init__(self, filename):
        self.filename = filename
        self.fh = open(self.filename, "r", encoding="utf-8")

    def close(self):
        self.fh.close()

    def read(self):
        data = self.fh.read()
        return data

    def __getstate__(self):
        attributes = {**self.__dict__, "fh": None}
        return attributes

    def __setstate__(self, state):
        # Відновлюємо стан об'єкта
        self.__dict__ = state
        self.fh = open(state["filename"], "r", encoding="utf-8")

if __name__ == "__main__":
    reader = Reader("data.txt")
    data = reader.read()
    print(data)
    reader.close()

    # Приклад серіалізації об'єкта Reader
    with open("reader.pkl", "wb") as f:
        pickle.dump(reader, f)

    # Приклад десеріалізації об'єкта Reader
    with open("reader.pkl", "rb") as f:
        loaded_reader = pickle.load(f)
        print(loaded_reader.read())
        loaded_reader.close()

""" У цій модифікованій версії, метод __getstate__ створює копію словника атрибутів об'єкта з self.__dict__, але 
замінює fh на None, щоб уникнути спроби серіалізації відкритого файлового дескриптора.

    ☝ Файловий дескриптор self.fh не включений до стану, тому що він не може бути серіалізованим.

Метод __setstate__ відновлює стан об'єкта зі стану, отриманого при десеріалізації, і відкриває файл знову, 
використовуючи збережене ім'я файлу. 

Це дозволяє нам знову отримати доступ до вмісту файлу після десеріалізації.

Загалом наша реалізація ефективно вирішує проблему з неможливістю серіалізації файлових дескрипторів і дозволяє 
безпечно зберігати та відновлювати стан об'єктів, що працюють з файлами.


                        Створення копій об'єктів в Python


Створення копій об'єктів у Python може виявитися нетривіальним завданням, залежно від того, чи потрібна вам поверхнева 
(shallow) або глибока (deep) копія, а також від складності структури даних об'єкта.

Python намагається заощаджувати пам'ять і не копіювати дані з однієї області пам'яті в іншу. Натомість інтерпретатор створює 
нове посилання, це ще один псевдонім, на реальний об'єкт, замість копіювання вмісту. Така поведінка може бути небажаною, 
розглянемо наприклад:"""

my_list = [1, 2, 3]
copy_list = my_list
copy_list.append(4)
print(my_list)

# Виведення:
# [1, 2, 3, 4]

""" Виходить, що copy_list — це просто ще одне ім'я для того самого списку my_list і, змінюючи copy_list, ми змінюємо й my_list. 
Це неочевидно і може збивати з пантелику.

Така поведінка може призводити до помилок, коли справа стосується типів, словників, списків, класів користувача, що змінюються.

Розглянемо приклад де ми передаємо список в середину функції, а вона його змінює:"""

my_list = [1, 2, 3]

def square_list(x: list):
    for i, el in enumerate(x):
        x[i] = el**2
    return x

new_list = square_list(my_list)
print(new_list)
print(my_list)

# Виведення:
# [1, 4, 9]
# [1, 4, 9]

""" Як бачимо список my_list зазнав змін, і можливо це зовсім небажана поведінка. У прикладі функція square_list 
приймає список x як аргумент і модифікує його, підносячи кожен елемент до квадрату. Виходить, що функція змінює вхідний 
список без створення нового списку. Тому коли ми передали my_list в square_list, оригінальний список my_list змінюється.

Якщо нам потрібно зберегти оригінальний список my_list без змін і створити новий список з квадратами елементів, то слід 
створити копію списку перед його зміною або змінити функцію, щоб вона повертала новий список з квадратами елементів, замість 
зміни вхідного списку. Наприклад:"""

my_list = [1, 2, 3]

def square_list(x: list):
    return [el**2 for el in x]

new_list = square_list(my_list)
print(new_list)
print(my_list)

# Виведення:
# [1, 4, 9]
# [1, 2, 3]

# Як бачимо, оригінальний список my_list тепер залишається без змін.

# Для списків та словників можна скористатися явним копіюванням:

my_list = [1, 2, 3]
copy_list = my_list[:]
copy_list.append(4)
print(my_list, copy_list)

my_dict = {1: "a"}
copy_dict = {**my_dict}
copy_dict["new_key"] = "new_value"
print(my_dict, copy_dict)

""" Інструкція copy_list = my_list[:] створює новий список copy_list, який є поверхневою копією my_list. Модифікація 
copy_list, як додавання елемента 4 не впливає тепер на список my_list. При створені словника copy_dict = {**my_dict} 
використовується синтаксис розпакування словника **, щоб створити новий словник copy_dict, який є копією my_dict. 

Тепер любі модифікації copy_dict, як наприклад додавання пари ключ-значення "new_key": "new_value" не впливають на 
початковий словник my_dict.

Тому виведення буде:
[1, 2, 3] [1, 2, 3, 4]
{1: 'a'} {1: 'a', 'new_key': 'new_value'}

Обидва наші приклади ілюструють як через зріз для списків або розпакування для словників отримати новий, незалежний 
об'єкт. Але з об’єктами класів та типами користувача так легко, це не зробиш. Щоб вирішити цю проблему, у Python є 
механізм копіювання — це функції із пакету copy.


                        Створення поверхневих копій об'єктів Python


Щоб створити "поверхневу" копію об'єкта, у пакеті copy є функція copy. Ця функція створює новий об'єкт такого самого типу 
і потім створює посилання на увесь вміст старого об'єкта в новий. Такий механізм досить хороший для роботи з об'єктами, де 
вже на першому рівні вкладеності немає змінних об'єктів, і він працює досить швидко."""

import copy

my_list = [1, 2, {"name": "Gupalo Vasyl"}]
copy_list = copy.copy(my_list)
copy_list.append(4)
print(my_list)
print(copy_list)

# Виведення:
# [1, 2, {'name': 'Gupalo Vasyl'}]
# [1, 2, {'name': 'Gupalo Vasyl'}, 4]

""" Поверхнева копія означає, що новий список copy_list буде містити нові посилання на ті ж самі об'єкти, що і оригінальний 
список і для об'єктів із глибокою вкладеністю така функція все ж таки не дасть потрібного ефекту. Тому вкладені об'єкти, такі 
як словник в третьому елементі списку, будуть спільними між оригінальним та скопійованим списками."""

import copy

my_list = [1, 2, {"name": "Gupalo Vasyl"}]
copy_list = copy.copy(my_list)
copy_list[2]["age"] = 30
print(my_list)
print(copy_list)

# Виведення:
# [1, 2, {'name': 'Gupalo Vasyl', 'age': 30}]
# [1, 2, {'name': 'Gupalo Vasyl', 'age': 30}]

""" З цього прикладу видно, що хоча copy_list вже є новим об'єктом, але вкладений у нього словник з індексом 2 — це один 
і той самий словник і в copy_list, і в my_list.

    ☝ Поверхнева копія створює новий об'єкт, але не копіює вкладені об'єкти. Замість цього, вона копіює лише посилання на 
    вкладені об'єкти. Це означає, що якщо ви змінюєте вкладені об'єкти в оригіналі, ці зміни також відобразяться у поверхневій 
    копії.


                        Створення глибоких копій об'єктів Python


Глибока копія створює новий об'єкт та рекурсивно копіює всі вкладені об'єкти. В результаті, ви отримуєте повністю незалежну 
копію оригінального об'єкта.

Для створення глибокої копії використовуйте метод deepcopy() модуля copy. Ця функція рекурсивно створює нові об'єкти."""

import copy

my_list = [1, 2, {"name": "Gupalo Vasyl"}]
copy_list = copy.deepcopy(my_list)
copy_list[2]["age"] = 30
print(my_list)
print(copy_list)

# Виведення:
# [1, 2, {'name': 'Gupalo Vasyl'}]
# [1, 2, {'name': 'Gupalo Vasyl', 'age': 30}]

""" Залежно від задачі, вам може бути достатньо використати поверхневу копію, або може знадобитися глибока копія для 
забезпечення повної незалежності даних. Головне розуміти структуру та залежності даних у вашому об'єкті, щоб обрати 
правильний метод копіювання."""